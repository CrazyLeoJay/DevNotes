# RTP协议

> https://www.cs.columbia.edu/~hgs/teaching/ais/1998/projects/java_rtp/report.html
>
> https://zhuanlan.zhihu.com/p/544970398?utm_id=0



## 参考文档

-  [RFC3550 RTP：实时应用程序的传输协议](http://www.ietf.org/rfc/rfc3550.txt)
-  [RFC3551 用于具有最小单元的音频和视频会议的 RTP 配置文件](http://www.ietf.org/rfc/rfc3551.txt) 
-  [IANA rtp-parameters : (IANA rtp 参数注册管理机构)](http://www.iana.org/assignments/rtp-parameters)
-  [关于哥伦比亚大学RTP的一些常见问题](http://www.cs.columbia.edu/\~hgs/rtp/faq.html)



# RTP 数据接收

### TCP header

> 当使用TCP协议时，需要通过这个头进行区分

RTP数据将以如下格式进行封装：（表头为顺序，值为长度）

| 标识符 | 信道 | 数据长度 | 报文 |
| ------ | ---- | -------- | ---- |
| 1      | 1    | 2        |      |

RTP数据标识符，"$" （0x24）这个一般是固定为0x24

信道数字 1个字节，用来指示信道。可以用来区分音视频等多路流媒体的通道，其中偶数通道为流媒体内容，奇数通道为RTCP(即0x00 一般代表rtp数据， 0x01 一般代表rtcp数据)

数据长度 2个字节，用来指示插入数据长度（数据包的长度减去开始的4个字节，即len字段之后的数据长度）

数据 - 数据包，比如说RTP包，总长度与上面的数据长度相同



### RTP结构

RTP数据格式：

```txt
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

> 翻译自[RFC3550 13页 --- 5. RTP Data Transfer Protocol](https://www.ietf.org/rfc/rfc3550.txt)

| 标记 | 占位                | 名称                                                         | 描述                                                         |
| ---- | ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| V    | 2bits               | RTP版本                                                      | 该字段标识RTP的版本。本规范定义的版本是2 。<br />值1用于RTP的第一个草案版本，<br />值0用于“vat”音频工具中最初实现的协议。 |
| P    | 1bit                | padding                                                      | 如果设置了填充位，则数据包在末尾包含一个或多个额外的填充字节，这些填充字节不属于负载的一部分。填充的最后一个八位字节包含应该忽略的填充八位字节数，包括其本身。某些具有固定块大小的加密算法或在较低层协议数据单元中携带多个RTP数据包可能需要填充。 |
| X    | 1bit                | extension                                                    | 如果设置了扩展位，固定报头必须紧跟一个报头扩展位，其格式在章节中定义5.3.1. |
| CC   | 4bits               | CSRC count                                                   | 证监会计数包含固定标头后面的证监会标识符的数量。             |
| M    | 1bit                | marker                                                       | 标记的解释由概要文件定义。它的目的是允许在数据包流中标记诸如帧边界之类的重要事件。配置文件可以定义额外的标记位，也可以通过改变有效载荷类型字段的位数来指定没有标记位(参见章节5.3)。 |
| PT   | 7bits               | [Payload Type](./reference/Real-Time Transport Protocol (RTP) Parameters.htm) | 该字段标识RTP有效负载的格式，并确定应用程序对其的解释。配置文件可以指定有效载荷类型代码到有效载荷格式的默认静态映射。额外的有效载荷类型代码可以通过非rtp方式动态定义(参见第3节)。<br />配套的RFC 3551[1]中指定了音频和视频的一组默认映射。RTP源可以在会话期间改变有效载荷类型，但是这个字段不应该用于多路复用单独的媒体流(参见章节5.2)。<br />接收方必须忽略其无法理解的有效载荷类型的数据包。<br />[查看定义 Payload Type Definitions](./reference/Real-Time Transport Protocol (RTP) Parameters.htm) |
| sn   | 16bits              | sequence number                                              | 每发送一个RTP数据包，序列号加1，接收方可以用它来检测数据包丢失和恢复数据包序列。序列号的初始值应该是随机的(不可预测的)，以使对加密的已知明文攻击更加困难，即使源本身没有根据9.1节中的方法进行加密，因为数据包可能流经一个进行加密的转换器。选择不可预测数字的技术在[17]中进行了讨论。 |
| ts   | 32bits              | timestamp                                                    | 时间戳反映了RTP数据包中第一个字节的采样时间。采样瞬间必须来源于一个时钟，该时钟随时间单调线性递增，以允许同步和抖动计算(参见6.4.1节)。时钟的分辨率必须足以满足所需的同步精度和测量数据包到达抖动(每个视频帧一个刻度通常是不够的)。时钟频率依赖于作为有效载荷携带的数据格式，在定义格式的配置文件或有效载荷格式规范中静态指定，或者可以动态指定通过非rtp方式定义的有效载荷格式。RTP包是周期性生成的，从采样时钟确定的标称采样瞬间将被使用，而不是读取系统时钟。例如，对于固定速率音频，时间戳时钟可能会为每个采样周期增加1。如果音频应用程序读取块覆盖如果 |
| SSRC | 32bits              | SSRC                                                         | SSRC字段标识同步源。这个标识符应该随机选择，目的是在同一个RTP会话中没有两个同步源具有相同的SSRC标识符。在附录a .6中给出了一个生成随机标识符的示例算法。尽管多个源选择相同标识符的概率很低，但所有RTP实现都必须准备好检测和解决冲突。第8节描述了冲突的概率，以及基于SSRC标识符的唯一性来解决冲突和检测rtp级转发环路的机制。如果一个源改变了它的源传输地址，它还必须选择一个新的SSRC标识符，以避免被解释为一个环路源(见8.2节)。 |
| CSRC | 0到15项，每项32bits | CSRC                                                         | 证监会列表标识了此包中包含的有效负载的贡献源。标识符的数量由CC字段给出。如果有超过15个贡献来源，只有15个可以被识别。证监会标识符由混合器插入(见7.1节)，使用贡献源的SSRC标识符。例如，对于音频数据包，列出了混合在一起以创建数据包的所有源的SSRC标识符，从而允许在接收者处进行正确的通话指示。 |

- [查看定义 Payload Type Definitions](./reference/Real-Time Transport Protocol (RTP) Parameters.htm)









## 字节转整型

> 第三位和第四位字节需要转换为整型长度值，可以参考一下方法
>
> [参考文献](https://blog.csdn.net/LABLENET/article/details/78921803)

Kotlin的位移操作符

​	shl(bits) – 左移位 (Java’s <<)
​	shr(bits) – 右移位 (Java’s >>)
​	ushr(bits) – 无符号右移位 (Java’s >>>)
​	and(bits) – 与
​	or(bits) – 或
​	xor(bits) – 异或

1. 按位与（AND）：将两个操作数的相应位进行逻辑与运算，只有当这两个位都为1时，结果位才会为1。
2. 按位或（OR）：将两个操作数的相应位进行逻辑或运算，只要这两个位中至少有一个为1，结果位就为1。
3. 按位异或（XOR）：将两个操作数的相应位进行逻辑异或运算，当两个位不同时，结果位为1，否则为0。
4. 取反（NOT）：对操作数的每个位进行逻辑取反运算，将0变为1，将1变为0。
5. [左移**](https://m.baidu.com/s?word=左移&sa=re_dqa_zy)（左位移）：将操作数的二进制表示向左移动指定的位数，左侧会填充0，并丢弃移出的位。
6. [右移**](https://m.baidu.com/s?word=右移&sa=re_dqa_zy)（右位移）：将操作数的二进制表示向右移动指定的位数，右侧会填充0或符号位，并丢弃移出的位

示例代码：

```kotlin
private fun ByteArray.toInt(): Int {
    return (((this[0].toInt() and 0xff) shl 8) or (this[1].toInt() and 0xff))
}
```

